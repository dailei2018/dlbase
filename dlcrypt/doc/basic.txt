[书本]
Understanding Cryptography
Handbook of Applied Cryptography
Encyclopedia of Cryptography and Security

[乘法逆元]
a < m, gcd(a, m) = 1
即 a 和 m 互质则 a 的乘法逆元(a⁻¹)肯定存在
a⁻¹ 与 m 也互质，因为 a⁻¹ 是 a 的乘法逆元，a 也是 a⁻¹ 的乘法逆元

那么 a.a⁻¹ ≡ 1 mod m 肯定成立

[例子]
假设 a = 3, 满足 gcd(a,26) = 1 即 3 与 26 互质，
则 a⁻¹ = 9，因为 3 * 9 = 27，27 ≡ 1 mod 26




Shfit Cipher / Caesar Cipher
[移位密码-恺撒密码]
let 0 <= x,y,k <= 25
x - 明文
y - 密文
k - 秘钥

Encryption: y ≡ x + k mod 26.
Decryption: x ≡ y − k mod 26




Affine Cipher
[仿射密码]

条件
0 <= x,y,a,b <= 25
gcd(a,26) = 1

x - 明文
y - 密文
(a, b) - 秘钥

Encryption: y ≡ a·x + b mod 26.
Decryption: x ≡ a⁻¹·(y − b) mod 26.

[推导]
a.x + b ≡ y mod 26
a·x ≡ (y − b) mod 26
x ≡ a⁻¹ ·(y − b) mod 26



[序列密码]
xi - 明文位
yi - 密文位
si - 0 | 1

yi ≡ xi + si mod 2


Pseudorandom Number Generators(PRNG)
[伪随机数生成器]

s₀ = seed
sᵢ₊₁ = f(sᵢ), i = 0,1,...

一般为线性同余生成器 - linear congruential generator
s₀ = seed
sᵢ₊₁ ≡ asᵢ + b mod m

ANSI C rand() 函数

s₀ = 12345
sᵢ₊₁ ≡ 1103515245sᵢ + 12345 mod 2³¹




[欧几里得算法]
假设 r0 > r1 且为正整数
gcd(r0, r1) = g = gcd(gx, gy)
则 x,y 互质，则 x - y 与 y 也互质

则 gcd(r0 - r1, r1) = gcd((x - y)g, gy) = g

则 gcd(r0, r1) = gcd(r0 - r1, r1)
以此循环下去就行

gcd(27, 21) = gcd(21, 27 % 21) = gcd(21, 6)
gcd(21, 6) = gcd(6, 21 % 6) = gcd(6, 3)
gcd(6, 3) = gcd(3, 6 % 3) = gcd(3, 0) = 3



[扩展欧几里得算法]
gcd(r0, r1) = s·r0 + t·r1

gcd(973, 301) = s.937 + t.301 = gcd(937 % 301, 301) = gcd(301, 70)
70 = [1]r0 + [-3]r1

gcd(301, 70) = gcd(70, 301 % 70) = gcd(70, 21)
21 = 301 - 4.70 = r1 - 4(1r0 -3r1) = [-4]r0 + [13]r1

gcd(70, 21) = gcd(21, 7)
7 = 70 - 21*3 = ([1]r0 + [-3]r1) - ([-4]r0 + [13]r1)*3 = [13]r0 + [-42]r1

gcd(21,7) = gcd(7,0) = 7
s = 13, t = -42




根据扩展欧几里得，如果a m互质则
gcd(a, m) = 1

ax + my = 1

y 即为 a 对于 m 的乘法逆元




[欧拉函数]
任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系
φ(8) = 4 (1,3,5,7)

特例1 - 如果n 可以分解为2个互质的数的乘积则
φ(n) = φ(p1p2) = φ(p1)φ(p2)

特例2 - 如果 n 为质数
φ(n) = n - 1


[欧拉定理]
如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立
a ^ φ(n) ≡ 1 mod n

[费马小定理]
如果 n 为质数则 φ(n) = n - 1
a ^ (n - 1) = ≡ 1 mod n




[RSA]
1.选择两个大质数 p q，计算出 n = p*q，n的位数即秘钥长度
2.计算 φ(n) = φ(pq) = φ(p)φ(p) = (p - 1)(q - 1)
3.计算 e (1 < e < φ(n) )，e 与 φ(n) 互质，实际应用一般选择 65537
4.计算 d，要求满足 ed ≡ 1 mod φ(n)

(n,e)即为公钥

y = x ^ e mod n - 加密
x = y ^ d mod n - 解密





Diffie–Hellman Key Exchange
[DHCK]
DH秘钥交换是通过双方约定一些参数，然后各自算出秘钥，而不必传输秘钥。

1.Alice选择一个大素数 P(最好大于等于1024)和一个数G(2..P-2)通常选择2
2.Alice把 P,G 发送给 Bob
3.Alice生成一个随机数 A(1..P-2)，保密
4.Bob生成一个随机数 B(1..P-2)，保密
5.Alice将 G^A mod P 数发给 Bob
6.Bob将 G^B mod P 发送给 Alice
7.Alice计算出共享秘钥 (G^B mod P)^A mod P
8.Bob计算出共享秘钥 (G^A mod P)^B mod P


(G^B mod P)^A mod P = G^(B*A) mod P
(G^A mod P)^B mod P = G^(B*A) mod P




one-way hash function 单向散列函数
message digest function 消息摘要函数
fingerprint 指纹




